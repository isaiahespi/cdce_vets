{
  "hash": "2e2abaae5f7552ddada6b6a4afe09117",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data Import, Clean, and Process\nauthor: Isaiah\n---\n\n\n\nThis document describes and executes the cleaning and processing of the survey data set downloaded from Qualtrics on 2024-09-11 at 11:39AM. Currently, this notebook is mainly to describe and explain the process undertaken in R to import, clean, and wrangle the data set for later analysis, but is derived from an R script that can be viewed [here](https://github.com/isaiahespi/cdce_vets/blob/80e843e8a9fa24d1d7524c76631b709f9f675876/scripts/01-data.R).  \n\n## Load data\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: load-data\n\n# load raw SPSS export that includes display order vars\nraw_spss <- haven::read_sav(file = \"vets_spss.sav\") \n```\n:::\n\n\n## Create data dictionary/codebook\n\nA data dictionary contains metadata about the data. The `labelled::generate_dictionary` function is used to create a data dictionary. A dataframe is loaded into the R environment with the number of observations equal to number of variables in the original data set.\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: raw-data-dict\n#| eval: false\n\nraw_spss_dict <- raw_spss |> labelled::generate_dictionary()\n```\n:::\n\n\n## create dataframe from raw data\n\nThe following code is lengthy, but creates a dataframe (object class `tbl_df` `tbl` `data.frame`) assigned as `data_spss`.\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: create-dataframe\n\n# create dataframe\ndata_spss <- raw_spss |>\n  janitor::clean_names() |>\n  # get rid of superfluous Qualtrics columns\n  # Keep Qualtrics `response_id`\n  dplyr::select(!1:8 & !10:17 & !265) |>\n  # put demographic data up front\n  dplyr::relocate(q59:q74, .before = q1) |>\n  # rename demographic vars and timing vars and identify lucid vars\n  dplyr::rename(\n    q13_treat_time = q13_page_submit,\n    q16_control_time = q16_page_submit,\n    lucid_gender = gender,\n    lucid_age = age,\n    lucid_hhi = hhi,\n    lucid_ethnicity = ethnicity,\n    lucid_hispanic = hispanic,\n    lucid_education = education,\n    lucid_political_party = political_party,\n    lucid_region = region,\n    lucid_zip = zip,\n    lucid_rid = rid,\n    gender = q59,\n    hisp = q60,\n    race = q61,\n    educ = q62,\n    milserv1 = q63,\n    milserv2 = q64,\n    milservfam = q65,\n    voted2020 = q66,\n    choice2020 = q67,\n    voteintent = q68,\n    partyid = q69,\n    partystr_rep = q70,\n    partystr_dem = q71,\n    partylean = q72,\n    ideo = q73,\n    ideolean = q74\n  ) |>\n  dplyr::relocate(lucid_rid, .after = response_id) |>\n  # set variable labels for embedded lucid vars\n  # set variable labels for select questions\n  labelled::set_variable_labels(\n    lucid_age = \"Lucid: age\",\n    lucid_gender = \"Lucid: What is your gender?\",\n    lucid_hhi = \"Lucid: What is your current Annual household income before taxes?\",\n    lucid_ethnicity = \"Lucid: What is your race?\",\n    lucid_hispanic = \"Lucid: Are you Hispanic, Latino, or Spanish Origin?\",\n    lucid_education = \"Lucid: What is the highest level of education you have completed?\",\n    lucid_political_party = \"Lucid: Generally Speaking, do you usually think yourself as a Republican, a Democrat, an Independent, or what?\",\n    lucid_region = \"Lucid: For Region, ZIP is asked which is automatically mapped to the Region\",\n    lucid_zip = \"Lucid: What is your ZIP code?\",\n    lucid_rid = \"Lucid respondent ID\",\n    q1 = \"Consent to Participate...\",\n    q28_1 = \"There will be voter fraud...\",\n    q28_2 = \"Many votes will not actually be counted\",\n    q28_3 = \"Many people will show up to vote and be told they are not eligible\",\n    q28_4 = \"A foreign country will tamper with the votes cast in Maricopa County, Arizona...\",\n    q28_5 = \"Election officials in Maricopa County, Arizoa will try to discourage some people from voting\",\n    q40_1 = \"There will be voter fraud...\",\n    q40_2 = \"Many votes will not actually be counted\",\n    q40_3 = \"Many people will show up to vote and be told they are not eligible\",\n    q40_4 = \"A foreign country will tamper with the votes cast in your local area...\",\n    q40_5 = \"Election officials in your community will try to discourage some people from voting\",\n    q41_1 = \"Election officials test every machine used in the election to ensure they are secure.\",\n    q41_2 = \"Election officials conduct audits of ballots after every election...\",\n    q41_3 = \"Poll watchers affiliated with the political parties or candidates observe the election.\",\n    q41_4 = \"Election staff and volunteers include military veterans and their family members from the community.\",\n    q41_5 = \"Election staff and volunteers include lawyers from the community.\",\n    q41_6 = \"Election staff and volunteers include college students from the community.\",\n    q43_1 = \"Election officials ensure that law enforcement officers are present at polling sites.\",\n    q43_2 = \"Poll watchers affiliated with the political parties or candidates observe the election.\",\n    q43_3 = \"People holding signs or giving out literature in support of a candidate or ballot question.\",\n    q43_4 = \"Election staff and volunteers include military veterans and their family members from the community.\",\n    q43_5 = \"Election staff and volunteers include lawyers from the community.\",\n    q43_6 = \"Election staff and volunteers include college students from the community.\",\n    q44_1 = \"Election officials test every machine used in the election to ensure they are secure.\",\n    q44_2 = \"Election officials conduct audits of ballots after every election to confirm the results were accurate.\",\n    q44_3 = \"Poll watchers affiliated with the political parties or candidates observe the election.\",\n    q44_4 = \"The majority of election staff and volunteers consist of military veterans and their family members from the community.\",\n    q44_5 = \"The majority of election staff and volunteers consist of lawyers from the community.\",\n    q44_6 = \"The majority of election staff and volunteers consist of college students from the community.\",\n    q46_1 = \"Election officials ensure that law enforcement officers are present at polling sites.\",\n    q46_2 = \"People holding signs or giving out literature in support of a candidate or ballot question.\",\n    q46_3 = \"Poll watchers affiliated with the political parties or candidates observe the election.\",\n    q46_4 = \"The majority of election staff and volunteers consist of military veterans and their family members from the community.\",\n    q46_5 = \"The majority of election staff and volunteers consist of lawyers from the community.\",\n    q46_6 = \"The majority of election staff and volunteers consist of college students from the community.\",\n    group = \"Experimental condition\",\n    qset = \"Condition A = question set [q41, q43] ; Condition B = question set [q44, q46]\"\n  ) |> \n  dplyr::filter(q1 == 1, # include only those who consented\n         q3 != 3,        # exclude non-U.S. citizens\n         q9 == 1 | q9 == 0 & q10 == 1 #exclude attn check failures\n         ) |>  \n  # add a column of ascending sequential row ids starting at 1 at start of df\n  tibble::rowid_to_column(\"rowID\")\n```\n:::\n\n\nThe `janitor` R package is used to `clean_names()` which ensures the column names of the dataframe are unique, consist only of the '_' character, numbers, and letters. All uppercase column names will be converted to lowercase (e.g., Q1 to q1). The `dplyr::select()`, `dplyr::relocate()`, and `dplyr::rename()` functions utilize the dplyr R package to...\n\n-   selectively remove superfluous columns that come standard when survey data is downloaded from Qualtrics; \n-   relocate demographic variables (e.g., Q59 to Q74) to a position just before the Q1 column and the Lucid rid ('lucid_rid') to a position just after the Qualtrics Response ID ('response_id');\n-   rename specific columns/variables.\n\nIn addition, the function `set_variable_labels()` from the `labelled` R package sets the *variable labels* attached to each respective variable[^1]. Crucially, the raw data is filtered using `dplyr::filter()` so the resulting dataframe only includes survey respondents who... \n\n-   Consented to take the survey\n-   Is a U.S. citizen\n-   Passed either attention check embedded within the survey.\n\nFinally, a column is added at the front of the dataframe ('rowID') which simply adds a column at the start of the dataframe of ascending sequential row ids starting at 1. The resulting dataframe (`tbl_df`) consists of $1,388$ rows, where each row consists of a valid survey response, and $254$ columns/variables.\n\n[^1]: *Variable* labels differ from *value* labels. The variable labels of this data set contain the question text of the particular survey question, truncated for some. For more detailed explanation and guidance on working with labelled data, usually imported from an SPSS .sav file, see the following resources: Shannon Pileggi's [Leveraging labelled data in R](https://www.pipinghotdata.com/posts/2020-12-23-leveraging-labelled-data-in-r/) and [The case for variable labels in R](https://www.pipinghotdata.com/posts/2022-09-13-the-case-for-variable-labels-in-r/); Joseph Larmarange's R package [labelled](https://larmarange.github.io/labelled/); and Daniel Lüdecke's [Labelled Data and the sjlabelled-Package](https://strengejacke.github.io/sjlabelled/articles/intro_sjlabelled.html) and the [sjlabelled package](https://strengejacke.github.io/sjlabelled/index.html). Also see Martin Chan's R package [surveytoolbox](https://martinctc.github.io/surveytoolbox/) which is also very helpful for [Working with SPSS labels in R](https://martinctc.github.io/blog/working-with-spss-labels-in-r/).  \n\n## Resolving errors in data\n\nThe responses to the age survey question (q2) in the dataframe (data_spss) reflect the response code rather than the respondent's actual reported age as selected from the drop-down list of ages ranging from '18' to '90 or\nolder'. Since age was indicated using a drop down list, the first response is coded as `1` which corresponds to age 18 in years. In addition, embedded data from Lucid also reflects the respondent's age, which has been renamed to `lucid_age`. The following code is used to illustrate this discrepancy.\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: age-discrepancies\n\n# verify that `age` and `q2` do not match at all in the numeric data frame\n# due to `q2` reflecting codes, not ages\n# note `lucid_age` is a character class object which is temporarily treated \n# as numeric\ndata_spss |> \n  dplyr::select(lucid_age, q2) |> \n  dplyr::mutate(\"match\" = \n                  ifelse(as.numeric(lucid_age) == q2, \"match\", \"no match\")) |> \n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n   lucid_age q2        match   \n   <chr>     <dbl+lbl> <chr>   \n 1 27        10 [27]   no match\n 2 70        53 [70]   no match\n 3 38        21 [38]   no match\n 4 33        16 [33]   no match\n 5 30        13 [30]   no match\n 6 35        18 [35]   no match\n 7 50        29 [46]   no match\n 8 60        43 [60]   no match\n 9 70        53 [70]   no match\n10 59        42 [59]   no match\n```\n\n\n:::\n:::\n\n\nThe output displays the first 10 observations and no match is found comparing the numeric values of the two variable columns. Note, however, that the 'lbl' of `q2` do, in fact, match the `lucid_age` values[^2].\n\n[^2]: At this point, most of the variable objects of the dataframe are class `\"haven_labelled\"` `\"vctrs_vctr\"` `\"double\"`, which means that the variable object in R has numeric values with *value labels* attached, hence `<dbl+lbl>`. According to description of the `labelled()` function in the `haven` R package, \"A labelled vector is a common data structure in other statistical environments, allowing you to assign text labels to specific values. This class makes it possible to import such labelled vectors in to R without loss of fidelity.\"\n\nAs such, the variable `q2` cannot simply be converted to numeric (class) using the `as.numeric()` function because value label (i.e., the 'lbl' in `<dbl+lbl>`) would be dropped, leaving the age values to incorrectly reflect the response codes rather than the actual age of the respondent. To resolve this problem, I use `dplyr::mutate()` and `dplyr::case_match()` to re-name the variable column and re-code the values to reflect the correct age and convert the object to a numeric class.\n   \n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: numeric-age-fix\n\ndata_spss <- data_spss |>\n  # rename `q2` to 'age' and recode values\n  dplyr::mutate(age = dplyr::case_match(\n      q2,\n      1 ~ 18,\n      2 ~ 19,\n      3 ~ 20,\n      4 ~ 21,\n      5 ~ 22,\n      6 ~ 23,\n      7 ~ 24,\n      8 ~ 25,\n      9 ~ 26,\n      10 ~ 27,\n      11 ~ 28,\n      12 ~ 29,\n      13 ~ 30,\n      14 ~ 31,\n      15 ~ 32,\n      16 ~ 33,\n      17 ~ 34,\n      18 ~ 35,\n      19 ~ 36,\n      20 ~ 37,\n      21 ~ 38,\n      22 ~ 39,\n      23 ~ 40,\n      24 ~ 41,\n      25 ~ 42,\n      26 ~ 43,\n      27 ~ 44,\n      28 ~ 45,\n      29 ~ 46,\n      30 ~ 47,\n      31 ~ 48,\n      32 ~ 49,\n      33 ~ 50,\n      34 ~ 51,\n      35 ~ 52,\n      36 ~ 53,\n      37 ~ 54,\n      38 ~ 55,\n      39 ~ 56,\n      40 ~ 57,\n      41 ~ 58,\n      42 ~ 59,\n      43 ~ 60,\n      44 ~ 61,\n      45 ~ 62,\n      46 ~ 63,\n      47 ~ 64,\n      48 ~ 65,\n      49 ~ 66,\n      50 ~ 67,\n      51 ~ 68,\n      52 ~ 69,\n      53 ~ 70,\n      54 ~ 71,\n      55 ~ 72,\n      56 ~ 73,\n      57 ~ 74,\n      58 ~ 75,\n      59 ~ 76,\n      60 ~ 77,\n      61 ~ 78,\n      62 ~ 79,\n      63 ~ 80,\n      64 ~ 81,\n      65 ~ 82,\n      66 ~ 83,\n      67 ~ 84,\n      68 ~ 85,\n      69 ~ 86,\n      70 ~ 87,\n      71 ~ 88,\n      72 ~ 89,\n      73 ~ 92 # one person reported '90 or older'. R's age in Lucid data is 92\n    ),\n    .after = q2, # place 'age' after `q2`\n    .keep = \"unused\" # drop `q2` from dataframe\n  ) |> \n  # set variable label consisting of question text\n  labelled::set_variable_labels(age = \"What is your age?\")\n```\n:::\n\n\nIt is still possible that the `lucid_age` variable doesn't match the re-coded `age` (formally `q2`) values. In fact, this is the case, as demonstrated by running the code below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: lucid-age-discrepancies\n\n# Identify counts of discrepancies between `lucid_age` and 'age'\ndata_spss |> \n  dplyr::select(rowID, lucid_age, age) |> \n  dplyr::mutate(match = ifelse(age == lucid_age, TRUE, FALSE)) |>\n  dplyr::summarise(\n    \"Matches\" = sum(match == TRUE, na.rm = T),\n    \"Non-match\" = sum(match == FALSE, na.rm = T)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  Matches `Non-match`\n    <int>       <int>\n1    1218         170\n```\n\n\n:::\n:::\n\n\nWhat results is confirmation that there are a total of $170$ discrepancies between the respondent's age as indicated by the embedded Lucid data and the age reported by the respondent in the survey. Thus, the age reported by the respondent in the survey will take precedence over the embedded data provided by Lucid[^3].\n\n[^3]: Note, however, that one of the response options for the question \"What is your age?\" (Q2) was \"90 or older\", and one respondent's age reported by Lucid was $92$ years old. Since there was no response code associated with being $92$ years of age, the response code `73` was recoded to represent $92$. In this one case, it was a stroke of luck that no more than one of the survey respondents happened to be 90 years of age or older. If there was, however, then there would have been no way to recode the `age` variable to reflect those respondent's actual age *and* convert the variable object to a numeric class. This issue isn't insurmountable, of course, but the lesson here is that it seems like best practice is to ensure respondents have to manually enter their age or birth year in the survey rather than choose from a list of options.\n\n## Recode variables to identify question display order  \n\nSurvey question items Q51 to Q58 were split up into two question sets: Q51 to Q54 and Q55 to Q58. The order of these question sets were randomly reversed. For order 1, questions Q51 to Q54 ('agent-aim') were presented first, followed by the next set, Q55 to Q58 ('agent-action-aim'). For order 2, the presentation was reversed. Two variable columns in the data set identify the question display order. Here I use those two variables to construct a single dummy variable where order 1 = 1, and order 2 = 0.\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: popeff-qdo\n\n# create var to identify display order of popular efficacy questions\ndata_spss <- data_spss |>\n  dplyr::mutate(\n    popeff_qdo = dplyr::case_when(\n      fl_22_do_popular_efficacy_agent_aim == 1 &\n        fl_22_do_popularefficacy_agent_action_aim == 2 ~ 1,\n      fl_22_do_popular_efficacy_agent_aim == 2 &\n        fl_22_do_popularefficacy_agent_action_aim == 1 ~ 0\n    ),\n    .after = qset,\n    .keep = \"unused\"\n  )\n```\n:::\n\n\n## Create data dictionary/codebook of labelled dataframe\n\nAs done with the raw data imported from .sav file (`raw_spss`), here I create another data dictionary (i.e., codebook) of the `data_spss` dataframe for reference later.  \n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: data-dict-spss\n\n# create data dictionary using `labelled::generate_dictionary()`\ndata_spss_dict <- data_spss |> \n  # subset spss data set to omit the display order variables\n  dplyr::select(!contains(\"_do_\")\n         & !contains(\"_ado_\")\n         & !contains(\"_click\")\n         & !contains(\"_count\")) |>\n  labelled::set_variable_labels(\n    popeff_qdo = \"Popular efficacy question display order\"\n  ) |> \n  labelled::generate_dictionary()\n```\n:::\n\n\n## Create dataframe with factors \n\nAs mentioned previously, labelled (SPSS) data is, well, labelled; the labelled variables are `<dbl+lbl>` which differs from factors `<fct>`[^4]. The following creates a new dataframe where the all the labelled variables `<dbl+lbl>` are converted to factors using `haven::as_factor()`. \n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: data-clean\n\n# covert all <dbl+lbl> vars to factor <fct> vars\n# remove all display order variables, as well as click counts\n# specifically convert `group` and `qset` to factor vars and set value labels\n# with associated values, i.e, levels with labels\n# re-code all blank levels \"\" to NA\n\ndata <- data_spss |>\n  # subset spss data set to omit the display order variables\n  dplyr::select(!contains(\"_do_\")\n         & !contains(\"_ado_\")\n         & !contains(\"_click\")\n         & !contains(\"_count\")) |>\n  \n  # make `group` and `qset` factors\n  dplyr::mutate(\n    group = forcats::fct(group, levels = c(\"Treatment\", \"Control\")),\n    qset = forcats::fct(qset, levels = c(\"A\", \"B\"), na = \"\")\n  ) |>\n  \n  # adds labels as attribute (named \"labels\") to group and qset, assign values\n  sjlabelled::set_labels(group, labels = c(\"Treatment\" = 1, \"Control\" = 0)) |>\n  sjlabelled::set_labels(qset, labels = c(\"A\" = 1, \"B\" = 0)) |>\n  \n  # convert all labelled variables in dataframe to factors\n  haven::as_factor(only_labelled = T) |>\n  \n  # re-code any empty/blank levels to NA\n  dplyr::mutate(dplyr::across(where(is.factor), \n                              ~ forcats::fct_recode(., NULL = \"\"))) |>\n  \n  # reverse order of identified factor levels for consist direction\n  dplyr::mutate(dplyr::across(c(q8, q20, q23, q24, q31, q34, q35, q49, q50), \n                .fns = ~ forcats::fct_rev(.)))\n```\n:::\n\n\n\nIn addition, the following unnecessary variables are removed...\n\n-   variable columns that indicate the display order of survey questions and the response option display order (e.g., `q5_do`, `q28_ado`)\n-   variable columns related to timing spent on a particular page: the first click, number, or count of clicks (e.g., `q13_first_click`, `q13_last_click`, `q13_click_count`)\n\nThe `group` variable identifies whether a survey respondent was in the \"Treatment\" or \"Control\" condition. The `qset` variable identifies which question set a respondent answered; set \"A\" indicates the respondent was presented Q41 and Q43, whereas set \"B\" indicates the respondent was presented Q44 and Q46 instead. Each of these variables were converted to factors using `forcats::fct()` prior to running `haven::as_factor()` because each is an object of class `character`. By default, `haven::as_factor()` applies `forcats::as_factor()` only to labelled variables in the dataframe. Since `group` and `qset` do no contain an associated *value* nor a *value label*, they would not be converted to class `factor`[^5]. The default argument of the function could be set to FALSE (i.e., `haven::as_factor(only_labelled = FALSE)`), but this would then convert **all** variables in the dataframe to factors, which is problematic considering the numeric variables that need to be preserved as such. \n\n[^4]: Factors (variable objects of class `factor`) are used for categorical variables in R. Mostly. To learn more, see the chapter on Factors in [R for Data Science](https://r4ds.hadley.nz/factors) by Hadley Wickham, Mine\n      Çetinkaya-Rundel, and Garrett Grolemund.\n\n[^5]: Of course, I could have simply used `dplyr::mutate(x = haven::as_factor(x))` again after running `as_factor()` for the whole dataframe, but this resulted in weirdness with the two variables that I didn't want to investigate and resolve. \n\nMoreover, any blank levels are recoded to `NA` rather than dropped. I'm sure any unused levels could be dropped, but that made me nervous for science reasons. Finally, an identified set of factor variables in the dataframe needed to have the orders of their levels reversed to remain consistent. Later, a similar, but different, operation is executed for the purely numeric dataframe. \n\n\n## Putting variable labels back into factor dataframe\n\nIt's easier to analyze variables in data as factors, but losing the variable labels (i.e., question text) is kind of a bummer. Variable labels are nice to have for plenty of reasons. The following puts the variable labels from the labelled (SPSS) data set back into the 'factor-ized' dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: put-var-labels-back\n\n# To quickly assign the variable labels, first create a named vector via\n# deframe() with values as the variable labels and names as the variable names.\ndata_labels <- data_spss_dict |>\n  dplyr::select(variable, label) |> \n  tibble::deframe()\n\n# Now assign the labels using the splice operator. Using the splice operator,\n# labels are assigned via matching against the variable name, which means that\n# variable order does not matter.\ndata <- data |> \n  labelled::set_variable_labels(!!!data_labels)\n```\n:::\n\n\n## Add Variables to the dataframe\n\nHere I construct the `partyid_3cat` variable from partisanship-related variables in the dataframe. Simply, this variable simplifies a respondent's self-reported party identification into either Democrat, Republican, or Independent by re-coding and combining responses to survey questions Q69, Q70, Q71, and Q72. I combined everyone who indicates some attachment to either the Democrat or Republican party (e.g., \"Strong\" and \"Not very strong\") to include self-described Independents who reportedly 'lean' more towards one party over the other. So, strong and weak Democrats as well as those who lean Democratic are all lumped into the Democrat group, and likewise for Republicans. Independents in this case only consist of true or 'pure' independents who don't think of themselves as Democrat or Republican and don't think of themselves as closer to either political party. \n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: add-partyid_3cat\n\n# construct the partyid var with 3 categories, true independents\ndata <- data |>\n  dplyr::mutate(\n    partyid_3cat = pewmethods::fct_case_when(\n      partyid == \"Republican\" ~ \"Republican\",\n      partystr_rep == \"Strong\" ~ \"Republican\",\n      partystr_rep == \"Not very strong\" ~ \"Republican\",\n      partylean == \"Republican\" ~ \"Republican\",\n      partyid == \"Democrat\" ~ \"Democrat\",\n      partystr_dem == \"Strong\" ~ \"Democrat\",\n      partystr_dem == \"Not very strong\" ~ \"Democrat\",\n      partylean == \"Democratic\" ~ \"Democrat\",\n      partyid == \"Independent\" ~ \"Independent\",\n      partyid == \"Other\" ~ \"Independent\",\n      partylean == \"Neither\" ~ \"Independent\"\n    ),\n    .before = partyid) |> \n  labelled::set_variable_labels(\n    partyid_3cat = \"Party ID 3 categories, with true Independents\")\n```\n:::\n\n\nNext I construct a variable consisting of eight age groups: 18-24, 25-34, 35-44, 45-54, 55-64, 65-74, 75-84, and 85-92 years of age.\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# create an age group variable\ndata <- data |>    \n  dplyr::mutate(age_cat = \n           forcats::fct_collapse(\n             forcats::as_factor(age),\n             \"18-24\" = c(18:24),\n             \"25-34\" = c(25:34),\n             \"35-44\" = c(35:44),\n             \"45-54\" = c(45:54),\n             \"55-64\" = c(55:64),\n             \"65-74\" = c(65:74),\n             \"75-84\" = c(75:82, 84),\n             \"85-92\" = c(85:88, 92)\n             ),\n         .after = age) |> \n  labelled::set_variable_labels(\n    age_cat = \"Age categorized into eight groups\"\n  )\n```\n:::\n\n\n## Dummify and Collapse Factors\n\nMost survey items consisted of Likert-type items with four or five response options to choose from. Many response items were ordinal in nature, with four options ranging from \"Not at all___\", \"Not too ___\", to \"Somewhat ___\",  \"Very ___\" or \"Always\". Collapsing such response options into two levels is done to illustrate comparison and highlight treatment effects should any be present between treatment and control groups. For instance, to illustrate distinction between expressing concern and expressing little to no concern about potential violence at polling sites, the four levels of the `q25` factor variable were collapsed into two levels, \"not_concerned\" and \"concerned\" and the modified variable name was affixed with \".clps\" to distinguish it in the dataframe. For survey items Q41 through Q46 where there were five response options, factor levels were collapsed into three levels where a neutral middle option was maintained: \"Increase confidence\", \"No impact\", and \"Decrease confidence\". \n\nThe following code merely calls and runs the source code from an R script located in the project directory, which can be found and viewed [here](https://github.com/isaiahespi/cdce_vets/blob/80e843e8a9fa24d1d7524c76631b709f9f675876/scripts/03-data-dummify.R).\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: add-dummy\n\n# call the dummify script sourced from the 'scripts/' directory\nsource(here::here('scripts', '03-data-dummify.R'))\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n# Attaching packages: easystats 0.7.3\n✔ bayestestR  0.14.0   ✔ correlation 0.8.5 \n✔ datawizard  0.12.3   ✔ effectsize  0.8.9 \n✔ insight     0.20.4   ✔ modelbased  0.8.8 \n✔ performance 0.12.3   ✔ parameters  0.22.2\n✔ report      0.5.9    ✔ see         0.9.0 \n```\n\n\n:::\n:::\n\n\n\n## Creating a purely numeric dataframe\n\nFor whatever reasons, it is sometimes preferred to use a purely numeric dataframe. The following code creates a dataframe from the earlier `data_spss` dataframe that removes all value labels from the numeric values of the variables, i.e., drops all the `lbl` from `<dbl+lbl>`.\n\nThe following code merely calls and runs the source code from an R script located in the project directory, which can be found and viewed [here](https://github.com/isaiahespi/cdce_vets/blob/80e843e8a9fa24d1d7524c76631b709f9f675876/scripts/02-data-numeric.R).\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n#| label: numeric-data-clean\n\ndata2 <- data_spss |>\n  # subset spss data set to omit the display order variables\n  select(!contains(\"_do_\")\n         & !contains(\"_ado_\")\n         & !contains(\"_click\")\n         & !contains(\"_count\")) |>\n  mutate(\n    group = case_when(\n      group == \"Treatment\" ~ 1,\n      group == \"Control\" ~ 0),\n    qset = case_when(\n      qset == \"A\" ~ 1,\n      qset == \"B\" ~ 0)) |>\n  \n  # remove all 'lbl' from all <dbl+lbl> variables, making them all numeric\n  haven::zap_labels() |> \n  # re-code values for consistent direction with like variables\n  mutate(\n    q8  = case_match(q8, 1 ~ 5, 2 ~ 4, 3 ~3, 4~2, 5 ~ 1),\n    q20 = case_match(q20, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q23 = case_match(q23, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q24 = case_match(q24, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q31 = case_match(q31, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q34 = case_match(q34, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q35 = case_match(q35, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q49 = case_match(q49, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1),\n    q50 = case_match(q50, 1 ~ 4, 2 ~ 3, 3 ~ 2, 4 ~ 1))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}